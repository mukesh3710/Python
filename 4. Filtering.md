

# ‚≠ê MODULE 4 ‚Äî FILTERING LOGIC (REAL-WORLD INVENTORY SCRIPT)

This module is where your Python script becomes *intelligent* ‚Äî it decides:

* Which hosts to include
* Which hosts to skip
* Which groups to ignore
* How to limit results
* How to clean/normalize data
* How to handle missing CMDB fields
* How to prepare the data before parsing patch groups (Module 5)

This is CRITICAL for stability of your automation.

You provided clear requirements:

### **Filters to implement:**

1. **Ignore specific hostnames**
2. **Ignore patching groups completely**
3. **Only accept certain OS strings**
4. **Limit max number of hosts returned to Tower**
5. **Drop hosts with missing group/slot/name**
6. **Normalize names (lowercase, replace space/hyphen)**
7. **Drop hosts that do not resolve in DNS** (will cover in Module 6)

This module covers **Points 1‚Äì6**.

---

# ‚≠ê 4.1 Define Constants (Ignore Lists, Supported OS, Limits)

You must define constant lists near the top of your script:

```python
IGNORE_HOSTS = [
    "test-do-not-patch",
    "old-backup-host",
    "example123"
]

IGNORE_GROUPS = [
    "storage",
    "network",
    "windows",
    "backup",
    "exclude-me"
]

SUPPORTED_OSES = [
    "Linux Red Hat",
    "Linux%20Red%20Hat",
    "Red Hat",
    "RHEL"
]

MAX_HOSTS = 15000  # Tower license limit
```

---

# ‚≠ê 4.2 Utility function ‚Äî Normalize names

Make hostnames & groups safe:

* lower case
* replace space with `_`
* replace `-` with `_`

```python
def normalize(value):
    if not value:
        return ""
    value = value.lower()
    value = value.replace(" ", "_")
    value = value.replace("-", "_")
    return value
```

You'll apply this to:

* hostname
* fadn
* patch group
* patch slot

---

# ‚≠ê 4.3 Filter: Ignore Hosts

```python
def is_ignored_host(hostname):
    hn = hostname.lower()
    for ignore in IGNORE_HOSTS:
        if hn.startswith(ignore):
            return True
    return False
```

Example:

```
"test-do-not-patch01" ‚Üí ignored
"example123-backend" ‚Üí ignored
```

---

# ‚≠ê 4.4 Filter: Ignore Groups

```python
def is_ignored_group(groupname):
    if not groupname:
        return True
    g = groupname.lower()
    return g in IGNORE_GROUPS
```

---

# ‚≠ê 4.5 Filter: Supported OS Only

ServiceNow returns OS like:

```
"Red Hat Enterprise Linux Server"
"Linux Red Hat"
"Linux CentOS"
```

You filter:

```python
def is_supported_os(os_name):
    os_name = os_name.lower()
    for supported in SUPPORTED_OSES:
        if supported.lower() in os_name:
            return True
    return False
```

Examples:

| OS in CMDB                 | Accepted? |
| -------------------------- | --------- |
| Red Hat Enterprise Linux 7 | ‚úî         |
| Linux Red Hat 8            | ‚úî         |
| CentOS 7                   | ‚úî         |
| Windows Server 2016        | ‚ùå         |
| Solaris                    | ‚ùå         |

---

# ‚≠ê 4.6 Limit Hosts (Tower license limit)

After pulling records from ServiceNow:

```python
if len(records) > MAX_HOSTS:
    print(f"Warning: Only using first {MAX_HOSTS} hosts from ServiceNow", file=sys.stderr)
records = records[:MAX_HOSTS]
```

---

# ‚≠ê 4.7 Filter records after SNOW query

### üéØ This is the real-world logic you need

```python
def filter_records(records):
    valid_hosts = []

    for r in records:
        hostname = normalize(r.get("name"))
        fadn     = normalize(r.get("fadn"))
        group    = normalize(r.get("u_patching_group"))
        slot     = normalize(r.get("u_patch_slot"))
        osname   = r.get("os", "")

        # DROP host if missing critical fields
        if not hostname and not fadn:
            print(f"Skipping host: missing hostname AND fadn ‚Üí {r}", file=sys.stderr)
            continue

        if not group:
            print(f"Skipping host: missing patch group ‚Üí {hostname}", file=sys.stderr)
            continue

        if not slot:
            print(f"Skipping host: missing patch slot ‚Üí {hostname}", file=sys.stderr)
            continue

        # Drop ignored hosts
        if is_ignored_host(hostname):
            print(f"Skipping ignored host ‚Üí {hostname}", file=sys.stderr)
            continue

        # Drop if group is in ignore list
        if is_ignored_group(group):
            print(f"Skipping ignored group '{group}' ‚Üí {hostname}", file=sys.stderr)
            continue

        # Drop if OS not supported
        if not is_supported_os(osname):
            print(f"Skipping unsupported OS ({osname}) ‚Üí {hostname}", file=sys.stderr)
            continue

        # If all filters pass, include host
        valid_hosts.append(r)

    return valid_hosts
```

---

# ‚≠ê 4.8 Putting Filters Together

### After querying ServiceNow:

```python
records = query_servicenow(user, pw, instance)
```

### Apply filters:

```python
records = filter_records(records)
```

### Apply limit:

```python
records = records[:MAX_HOSTS]
```

### Now you have **clean, safe, validated records** ready for Module 5:

* patch group parsing
* priority
* slot
* wave mapping
* distribution into inventory

---

# ‚≠ê 4.9 Example Result After Filtering

ServiceNow returns ‚Üí 10,000 hosts
Filtering removes ‚Üí 2100 (invalid group, ignore, missing slot, wrong OS)
Output ‚Üí 7,900 valid hosts

Now next module will distribute them **fairly** by wave and priority.

---

# ‚≠ê MODULE 4 SUMMARY

You now know how to:

‚úî Normalize hostnames/groups
‚úî Drop invalid CMDB entries
‚úî Drop ignored groups (UNIX doesn't patch them)
‚úî Drop ignored hosts
‚úî Drop unsupported OS
‚úî Enforce max limit
‚úî Prepare clean list for next steps

This is exactly how production-grade AAP dynamic inventory scripts work.

You have now implemented the **core filtering brain** of the script.

